# final-java-core
[![Java CI with Gradle](https://github.com/danilaplayter/final-java-core/actions/workflows/main.yml/badge.svg)](https://github.com/danilaplayter/final-java-core/actions/workflows/main.yml)

CoinKeeper — это интуитивное приложение для управления личными финансами, разработанное для упрощения контроля над доходами, расходами.

1. Реализованные методы :
   
Добавление дохода	add income <сумма> <категория> [описание]	add income 5000 SALARY Зарплата
Добавление расхода	add expense <сумма> <категория> [описание]	add expense 1500 GOODS Продукты
Просмотр всех транзакций	list all	list all
Просмотр доходов	list income	list income
Просмотр расходов	list expense	list expense
Показать баланс	balance	balance
Сводка по категориям расходов	summary	summary
Удаление транзакции	delete <ID>	delete 3
Выход	exit	exit

2. Тестовая стратегия:

Классы/методы, покрытые тестами:

Класс FinanceService:

addTransaction(): добавление транзакций.
getAllTransactions(): получение всех транзакций.
getTransactionsByType(): фильтрация по типу (INCOME/EXPENSE).
getTransactionsByCategory(): фильтрация по категории.
calculateBalance(): расчёт баланса.
getExpensesByCategory(): сводка расходов по категориям.
deleteTransaction(): удаление транзакции.

Класс FinanceService:
Покрытие инструкций (Line Coverage): 100%(34/34).
Покрытие ветвей (Branch Coverage): 100%(16/16).

3. Сборка проекта
   Для сборки проекта выполините команду ./gradlew build. Собранный JAR-файл будет доступен в build\libs.

4. Запуск приложения.
   1. Через Gradle. Запустите программу через ./gradlew run
   2. Через JAR-файл. Запустите через команду java -jar build/libs/your-project-name-{version}.jar(ВАЖНО! Укажите актуальную версию вашего проекта в {version})

5. Описание видов тестов и обоснование выбора сценариев
   1. Позитивные тесты. Проверяют корректную работу системы при валидных входных данных и стандартных условиях.

      1. addTransaction_ValidData_ReturnsCreatedTransaction.   Добавление транзакции с корректными полями.   Гарантирует, что основная функциональность (создание транзакции) работает без ошибок.
      2. getAllTransactions_ReturnsAllTransactionsSorted.   Получение всех транзакций с проверкой сортировки.   Убеждает, что данные сохраняются и возвращаются в правильном порядке (например, по дате).
      3. getTransactionsByType_ReturnsFilteredResults.   Фильтрация по типу (доход/расход).   Проверяет корректность фильтрации — ключевой функции для анализа финансов.
      4. calculateBalance_WithTransactions_ReturnsCorrectBalance.   Расчет баланса при наличии транзакций.   Подтверждает правильность вычислений, что критично для финансовых приложений.
      5. getExpensesByCategory_ReturnsCorrectSummary.   Группировка расходов по категориям.   Обеспечивает корректность аналитики — основы для принятия решений.
   2. Негативные тесты. Проверяют обработку невалидных данных и ошибочных сценариев.
      1. addTransaction_ZeroAmount_ThrowsException.	Попытка добавить транзакцию с нулевой суммой.	Предотвращает учет "пустых" операций, которые искажают баланс.
      2. addTransaction_NegativeAmount_ThrowsException.   Добавление транзакции с отрицательной суммой.   Исключает некорректные финансовые операции (сумма всегда положительна).
      3. addTransaction_NullCategory_ThrowsException.   Создание транзакции без категории.   Категория обязательна для классификации операций — тест предотвращает NullPointerException.
      4. deleteTransaction_NonExistingId_ReturnsFalse.   Удаление несуществующей транзакции.   Гарантирует стабильность приложения при ошибочных запросах.
   3. Граничные тесты. Проверяют поведение системы на граничных значениях и пограничных условиях.
      1. addTransaction_MinimumAmount_Allowed.   Добавление транзакции с суммой 0.01.   Проверяет нижнюю границу допустимого значения суммы.
      2. calculateBalance_NoTransactions_ReturnsZero.   Расчет баланса при отсутствии транзакций.   Убеждает, что приложение корректно обрабатывает "пустые" данные.
      3. getTransactionsByType_NonExistingType_ReturnsEmpty.   Фильтрация по несуществующему типу.   Проверяет обработку отсутствующих данных без ошибок.
         
6. Обоснование выбора сценариев
   Покрытие ключевых функций:
      Тесты охватывают все основные операции: добавление, удаление, фильтрацию, расчет баланса, аналитику по категориям. Это минимизирует риск дефектов в основных сценариях использования.
   Защита от некорректных данных:
      Негативные тесты проверяют:
         Валидацию сумм (отрицательные, нулевые).
         Обязательность полей (категория).  
         Обработку несуществующих ID при удалении.
   Работа с крайними случаями:
      Граничные тесты:
         Гарантируют корректность вычислений при минимально допустимых значениях (0.01).   
         Проверяют стабильность при отсутствии данных (пустые списки транзакций).
   Контроль бизнес-логики:
      Например, тест getExpensesByCategory_ReturnsCorrectSummary проверяет:   
      Корректность группировки данных.
      Правильность арифметических операций (суммирование расходов по категориям).   
